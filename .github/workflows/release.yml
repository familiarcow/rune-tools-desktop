name: Release Build

on:
  push:
    tags: ['v*']

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Import Apple certificates (macOS)
        if: runner.os == 'macOS'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create keychain
          security create-keychain -p actions build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p actions build.keychain
          
          # Import certificate
          echo $APPLE_CERTIFICATE | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P $APPLE_CERTIFICATE_PASSWORD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
          
          # Clean up
          rm certificate.p12

      - name: Import GPG key (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key
          gpg --batch --import /tmp/private.key
          rm /tmp/private.key
          gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }} << EOF
          trust
          5
          y
          save
          quit
          EOF

      - name: Import GPG key (Windows)
        if: runner.os == 'Windows'
        run: |
          $key = [System.Convert]::FromBase64String("${{ secrets.GPG_PRIVATE_KEY }}")
          Set-Content -Path "private.key" -Value $key -Encoding Byte
          gpg --batch --import private.key
          Remove-Item private.key
          "trust", "5", "y", "save", "quit" | gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }}
        shell: powershell


      - name: Build application (macOS) 
        if: runner.os == 'macOS'
        run: |
          echo "üî® Building Electron app with standard electron-builder notarization..."
          echo "üìã electron-builder will handle the complete Apple sequence:"
          echo "   1. Build and sign app bundle with Developer ID certificate"
          echo "   2. Submit app bundle to Apple for notarization"
          echo "   3. Wait for Apple approval and download ticket"
          echo "   4. Staple notarization ticket to app bundle"
          echo "   5. Create DMG containing the notarized app"
          echo "   6. Submit DMG to Apple for notarization" 
          echo "   7. Staple notarization ticket to DMG"
          echo "   8. Final notarized DMG ready for distribution"
          echo ""
          npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          CSC_IDENTITY_AUTO_DISCOVERY: false
          CSC_NAME: "Developer ID Application: Tyler Bond (974SWJKYUP)"
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Build application (Windows)
        if: runner.os == 'Windows'
        run: npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Create release manifest
        run: node scripts/create-manifest.js
      
      - name: Extract changelog for current version
        run: node scripts/extract-changelog.js

      - name: Sign manifest
        run: gpg --batch --yes --armor --detach-sign release-manifest.json

      - name: Verify electron-builder notarization (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "üîç VERIFYING: electron-builder's notarization results"
          echo "Expected: notarized app bundle inside unsigned DMG (Apple best practice)"
          echo ""
          
          # Find the DMG created by electron-builder
          DMG_FILE=$(find dist-electron -name "*.dmg" -type f | head -1)
          
          if [ -z "$DMG_FILE" ]; then
            echo "‚ùå CRITICAL: No DMG file found!"
            echo "electron-builder may have failed to create DMG"
            exit 1
          fi
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ Testing electron-builder DMG: $DMG_FILE"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Test 1: DMG should be unsigned (Apple best practice)
          echo "üîç Test 1: DMG signature check (should be unsigned)"
          if xcrun stapler validate "$DMG_FILE" 2>/dev/null; then
            echo "‚ö†Ô∏è WARNING: DMG has notarization ticket (not recommended by Apple)"
          else
            echo "‚úÖ DMG is unsigned/unnotarized (correct per Apple guidelines)"
          fi
          
          # Test 2: DMG Gatekeeper assessment  
          echo "üîç Test 2: DMG Gatekeeper assessment"
          SPCTL_OUTPUT=$(spctl -a -vvv "$DMG_FILE" 2>&1 || true)
          echo "Gatekeeper output: $SPCTL_OUTPUT"
          if echo "$SPCTL_OUTPUT" | grep -q "accepted"; then
            echo "‚úÖ DMG passes Gatekeeper assessment"
          else
            echo "‚ö†Ô∏è DMG Gatekeeper assessment unclear - checking app inside"
          fi
          
          # Test 3: App inside DMG
          echo "üîç Test 3: App inside DMG"
          MOUNT_POINT="/tmp/eb-test-mount-$$"
          mkdir -p "$MOUNT_POINT"
          
          if hdiutil attach "$DMG_FILE" -mountpoint "$MOUNT_POINT" -quiet; then
            APP_IN_DMG=$(find "$MOUNT_POINT" -name "*.app" -type d | head -1)
            if [ -n "$APP_IN_DMG" ]; then
              echo "Found app: $APP_IN_DMG"
              
              # Test app notarization
              echo "üîç Test 3a: App notarization ticket"
              if xcrun stapler validate "$APP_IN_DMG"; then
                echo "‚úÖ App has valid notarization ticket"
              else
                echo "‚ùå CRITICAL: App lacks notarization ticket!"
                hdiutil detach "$MOUNT_POINT" -quiet || true
                exit 1
              fi
              
              # Test app Gatekeeper
              echo "üîç Test 3b: App Gatekeeper assessment"
              APP_SPCTL_OUTPUT=$(spctl -a -vvv "$APP_IN_DMG" 2>&1 || true)
              echo "App Gatekeeper output: $APP_SPCTL_OUTPUT"
              if echo "$APP_SPCTL_OUTPUT" | grep -q "accepted"; then
                echo "‚úÖ App passes Gatekeeper assessment"
              else
                echo "‚ùå CRITICAL: App fails Gatekeeper assessment!"
                echo "Full spctl output: $APP_SPCTL_OUTPUT"
                hdiutil detach "$MOUNT_POINT" -quiet || true
                exit 1
              fi
            else
              echo "‚ùå No app found in DMG"
              hdiutil detach "$MOUNT_POINT" -quiet || true
              exit 1
            fi
            
            hdiutil detach "$MOUNT_POINT" -quiet || true
          else
            echo "‚ùå Failed to mount DMG"
            exit 1
          fi
          
          echo ""
          echo "üéâ SUCCESS: electron-builder followed Apple best practices!"
          echo "‚úÖ DMG is unsigned (recommended by Apple)"
          echo "‚úÖ App inside DMG is notarized and stapled"  
          echo "‚úÖ App passes Gatekeeper assessment"
          echo "‚úÖ Ready for distribution"

      - name: Create GitHub release with preserved notarization
        if: runner.os == 'macOS'
        run: |
          echo "üöÄ Creating GitHub release with preserved file attributes..."
          VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
          
          # Create the release
          gh release create "v${VERSION}" \
            --title "Rune Tools Desktop v${VERSION}" \
            --notes-file changelog.md \
            --verify-tag
          
          echo "üì¶ Uploading release assets with preserved notarization..."
          
          # Upload DMG files with preserved extended attributes
          for file in dist-electron/*.dmg; do
            if [ -f "$file" ]; then
              echo "Uploading notarized DMG: $file"
              # Use gh CLI which should preserve macOS extended attributes
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload other platform files
          for file in dist-electron/*.pkg dist-electron/*.zip dist-electron/*.exe; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"  
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload manifest and signature
          gh release upload "v${VERSION}" release-manifest.json
          gh release upload "v${VERSION}" release-manifest.json.asc
          
          echo "üéâ All assets uploaded successfully with preserved attributes"
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Windows release upload
        if: runner.os == 'Windows'  
        run: |
          Write-Host "Uploading Windows release assets..."
          $VERSION = "${{ github.ref_name }}" -replace '^v', ''
          
          # Upload Windows files
          Get-ChildItem dist-electron/*.exe, dist-electron/*.zip | ForEach-Object {
            if (Test-Path $_.FullName) {
              Write-Host "Uploading: $($_.Name)"
              gh release upload "v$VERSION" $_.FullName
              Write-Host "Uploaded: $($_.Name)"
            }
          }
          
          # Upload manifest files (created by macOS job)  
          if (Test-Path release-manifest.json) {
            gh release upload "v$VERSION" release-manifest.json
            gh release upload "v$VERSION" release-manifest.json.asc
          }
          
          Write-Host "Windows assets uploaded successfully"
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

