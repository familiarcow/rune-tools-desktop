name: Release Build

on:
  push:
    tags: ['v*']

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Import Apple certificates (macOS)
        if: runner.os == 'macOS'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create keychain
          security create-keychain -p actions build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p actions build.keychain
          
          # Import certificate
          echo $APPLE_CERTIFICATE | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P $APPLE_CERTIFICATE_PASSWORD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
          
          # Clean up
          rm certificate.p12

      - name: Import GPG key (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key
          gpg --batch --import /tmp/private.key
          rm /tmp/private.key
          gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }} << EOF
          trust
          5
          y
          save
          quit
          EOF

      - name: Import GPG key (Windows)
        if: runner.os == 'Windows'
        run: |
          $key = [System.Convert]::FromBase64String("${{ secrets.GPG_PRIVATE_KEY }}")
          Set-Content -Path "private.key" -Value $key -Encoding Byte
          gpg --batch --import private.key
          Remove-Item private.key
          "trust", "5", "y", "save", "quit" | gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }}
        shell: powershell


      - name: Build application (macOS) 
        if: runner.os == 'macOS'
        run: |
          echo "üî® Building Electron app with custom notarization (Asgardex-style)..."
          echo "üìã Process sequence:"
          echo "   1. electron-builder builds and signs app bundle with Developer ID certificate"
          echo "   2. Custom afterSign hook (scripts/notarize.js) handles notarization:"
          echo "      - Uses App Store Connect API key authentication (preferred)"
          echo "      - Falls back to Apple ID authentication if needed"
          echo "      - Implements retry logic with exponential backoff"
          echo "      - Submits app bundle to Apple for notarization"
          echo "      - Downloads and staples notarization ticket to app bundle"
          echo "   3. electron-builder creates DMG containing the notarized app"
          echo "   4. Final DMG ready for distribution (unsigned DMG, notarized app inside)"
          echo ""
          npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          CSC_IDENTITY_AUTO_DISCOVERY: false
          CSC_NAME: "Developer ID Application: Tyler Bond (974SWJKYUP)"
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Build application (Windows)
        if: runner.os == 'Windows'
        run: npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Create release manifest
        run: node scripts/create-manifest.js
      
      - name: Extract changelog for current version
        run: node scripts/extract-changelog.js

      - name: Sign manifest
        run: gpg --batch --yes --armor --detach-sign release-manifest.json

      - name: Verify electron-builder notarization (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "üîç VERIFYING: Custom notarization results"
          echo "Expected: notarized app bundle inside unsigned DMG (Asgardex-style)"
          echo ""
          
          # Find the DMG created by electron-builder
          DMG_FILE=$(find dist-electron -name "*.dmg" -type f | head -1)
          
          if [ -z "$DMG_FILE" ]; then
            echo "‚ùå CRITICAL: No DMG file found!"
            echo "electron-builder may have failed to create DMG"
            exit 1
          fi
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ Testing electron-builder DMG: $DMG_FILE"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Test 1: DMG should have notarization ticket (correct approach)
          echo "üîç Test 1: DMG notarization ticket check"
          if xcrun stapler validate "$DMG_FILE" 2>/dev/null; then
            echo "‚úÖ DMG has notarization ticket (correct for DMG distribution)"
          else
            echo "‚ùå CRITICAL: DMG lacks notarization ticket"
            exit 1
          fi
          
          # Test 2: DMG Gatekeeper assessment  
          echo "üîç Test 2: DMG Gatekeeper assessment"
          SPCTL_OUTPUT=$(spctl -a -vvv "$DMG_FILE" 2>&1 || true)
          echo "Gatekeeper output: $SPCTL_OUTPUT"
          if echo "$SPCTL_OUTPUT" | grep -q "accepted"; then
            echo "‚úÖ DMG passes Gatekeeper assessment"
          else
            echo "‚ö†Ô∏è DMG Gatekeeper assessment unclear - checking app inside"
          fi
          
          # Test 3: App inside DMG can be launched (functionality test)
          echo "üîç Test 3: App inside DMG functionality"
          MOUNT_POINT="/tmp/eb-test-mount-$$"
          mkdir -p "$MOUNT_POINT"
          
          if hdiutil attach "$DMG_FILE" -mountpoint "$MOUNT_POINT" -quiet; then
            APP_IN_DMG=$(find "$MOUNT_POINT" -name "*.app" -type d | head -1)
            if [ -n "$APP_IN_DMG" ]; then
              echo "Found app: $APP_IN_DMG"
              echo "‚úÖ App extracted successfully from notarized DMG"
              echo "üìã NOTE: App inherits notarization from parent DMG"
            else
              echo "‚ùå No app found in DMG"
              hdiutil detach "$MOUNT_POINT" -quiet || true
              exit 1
            fi
            
            hdiutil detach "$MOUNT_POINT" -quiet || true
          else
            echo "‚ùå Failed to mount DMG"
            exit 1
          fi
          
          echo ""
          echo "üéâ SUCCESS: DMG notarization worked perfectly!"
          echo "‚úÖ DMG has notarization ticket stapled to it"
          echo "‚úÖ DMG can be distributed via GitHub releases"  
          echo "‚úÖ App inside DMG inherits notarization from parent DMG"
          echo "‚úÖ Ready for distribution"

      - name: Create GitHub release with preserved notarization
        if: runner.os == 'macOS'
        run: |
          echo "üöÄ Creating GitHub release with preserved file attributes..."
          VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
          
          # Create the release
          gh release create "v${VERSION}" \
            --title "Rune Tools Desktop v${VERSION}" \
            --notes-file changelog.md \
            --verify-tag
          
          echo "üì¶ Uploading release assets with preserved notarization..."
          
          # Upload DMG files with preserved extended attributes
          for file in dist-electron/*.dmg; do
            if [ -f "$file" ]; then
              echo "Uploading notarized DMG: $file"
              # Use gh CLI which should preserve macOS extended attributes
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload other platform files
          for file in dist-electron/*.pkg dist-electron/*.zip dist-electron/*.exe; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"  
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload manifest and signature
          gh release upload "v${VERSION}" release-manifest.json
          gh release upload "v${VERSION}" release-manifest.json.asc
          
          echo "üéâ All assets uploaded successfully with preserved attributes"
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Post-upload notarization validation (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "üîç CRITICAL: Validating uploaded release preserves notarization..."
          VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
          
          # Wait for upload to propagate
          echo "‚è≥ Waiting 30 seconds for GitHub release propagation..."
          sleep 30
          
          # Download the uploaded DMG
          DOWNLOAD_DIR="/tmp/release-validation-$$"
          mkdir -p "$DOWNLOAD_DIR"
          cd "$DOWNLOAD_DIR"
          
          # Download using curl to simulate user experience
          DMG_NAME=$(ls -1 ../../../dist-electron/*.dmg | head -1 | xargs basename)
          RELEASE_URL="https://github.com/familiarcow/rune-tools-desktop/releases/download/v${VERSION}/${DMG_NAME}"
          
          echo "üì• Downloading from GitHub releases: $RELEASE_URL"
          curl -L -o "downloaded.dmg" "$RELEASE_URL"
          
          if [ ! -f "downloaded.dmg" ]; then
            echo "‚ùå CRITICAL: Failed to download DMG from GitHub releases"
            exit 1
          fi
          
          # Validate the downloaded DMG has notarization ticket
          echo "üîç Validating downloaded DMG notarization..."
          if xcrun stapler validate "downloaded.dmg"; then
            echo "‚úÖ SUCCESS: Downloaded DMG has valid notarization ticket"
            
            # Also test spctl on the DMG
            if spctl -a -vvv "downloaded.dmg" 2>&1 | grep -q "accepted"; then
              echo "‚úÖ SUCCESS: Downloaded DMG passes Gatekeeper assessment"
              echo "üéâ NOTARIZATION PRESERVED through GitHub releases!"
            else
              echo "‚ö†Ô∏è DMG spctl check unclear - this is normal for DMG files"
              echo "‚úÖ DMG notarization ticket is present and valid"
              echo "üéâ NOTARIZATION PRESERVED through GitHub releases!"
            fi
          else
            echo "‚ùå CRITICAL: Downloaded DMG LACKS notarization ticket"
            echo "‚ùå NOTARIZATION LOST during GitHub upload/download"
            exit 1
          fi
          
          # Cleanup
          rm -rf "$DOWNLOAD_DIR"
          echo "‚úÖ Post-upload validation PASSED - releases preserve notarization"
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Windows release upload
        if: runner.os == 'Windows'  
        run: |
          Write-Host "Uploading Windows release assets..."
          $VERSION = "${{ github.ref_name }}" -replace '^v', ''
          
          # Upload Windows files
          Get-ChildItem dist-electron/*.exe, dist-electron/*.zip | ForEach-Object {
            if (Test-Path $_.FullName) {
              Write-Host "Uploading: $($_.Name)"
              gh release upload "v$VERSION" $_.FullName
              Write-Host "Uploaded: $($_.Name)"
            }
          }
          
          # Upload manifest files (created by macOS job)  
          if (Test-Path release-manifest.json) {
            gh release upload "v$VERSION" release-manifest.json
            gh release upload "v$VERSION" release-manifest.json.asc
          }
          
          Write-Host "Windows assets uploaded successfully"
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

