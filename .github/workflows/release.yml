name: Release Build

on:
  push:
    tags: ['v*']

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-latest, windows-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Import Apple certificates (macOS)
        if: runner.os == 'macOS'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create keychain
          security create-keychain -p actions build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p actions build.keychain
          
          # Import certificate
          echo $APPLE_CERTIFICATE | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P $APPLE_CERTIFICATE_PASSWORD -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k actions build.keychain
          
          # Clean up
          rm certificate.p12

      - name: Import GPG key (Unix)
        if: runner.os != 'Windows'
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key
          gpg --batch --import /tmp/private.key
          rm /tmp/private.key
          gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }} << EOF
          trust
          5
          y
          save
          quit
          EOF

      - name: Import GPG key (Windows)
        if: runner.os == 'Windows'
        run: |
          $key = [System.Convert]::FromBase64String("${{ secrets.GPG_PRIVATE_KEY }}")
          Set-Content -Path "private.key" -Value $key -Encoding Byte
          gpg --batch --import private.key
          Remove-Item private.key
          "trust", "5", "y", "save", "quit" | gpg --batch --yes --command-fd 0 --edit-key ${{ secrets.GPG_KEY_ID }}
        shell: powershell


      - name: Build application (macOS) 
        if: runner.os == 'macOS'
        run: |
          echo "üî® Building Electron app with custom notarization (Asgardex-style)..."
          echo "üìã Process sequence:"
          echo "   1. electron-builder builds and signs app bundle with Developer ID certificate"
          echo "   2. Custom afterSign hook (scripts/notarize.js) handles notarization:"
          echo "      - Uses App Store Connect API key authentication (preferred)"
          echo "      - Falls back to Apple ID authentication if needed"
          echo "      - Implements retry logic with exponential backoff"
          echo "      - Submits app bundle to Apple for notarization"
          echo "      - Downloads and staples notarization ticket to app bundle"
          echo "   3. electron-builder creates DMG containing the notarized app"
          echo "   4. Final DMG ready for distribution (unsigned DMG, notarized app inside)"
          echo ""
          npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          CSC_IDENTITY_AUTO_DISCOVERY: false
          CSC_NAME: "Developer ID Application: Tyler Bond (974SWJKYUP)"
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Build application (Windows)
        if: runner.os == 'Windows'
        run: npm run dist
        timeout-minutes: 90
        env:
          DEBUG: electron-builder
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Create release manifest
        run: node scripts/create-manifest.js
      
      - name: Extract changelog for current version
        run: node scripts/extract-changelog.js

      - name: Sign manifest
        run: gpg --batch --yes --armor --detach-sign release-manifest.json

      - name: Verify electron-builder notarization (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "üîç VERIFYING: Custom notarization results"
          echo "Expected: notarized app bundle inside unsigned DMG (Asgardex-style)"
          echo ""
          
          # Find the DMG created by electron-builder
          DMG_FILE=$(find dist-electron -name "*.dmg" -type f | head -1)
          
          if [ -z "$DMG_FILE" ]; then
            echo "‚ùå CRITICAL: No DMG file found!"
            echo "electron-builder may have failed to create DMG"
            exit 1
          fi
          
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì¶ Testing electron-builder DMG: $DMG_FILE"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          
          # Test 1: DMG should be unsigned, app inside should be notarized
          echo "üîç Test 1: DMG should be unsigned (standard practice)"
          if xcrun stapler validate "$DMG_FILE" 2>/dev/null; then
            echo "‚ö†Ô∏è DMG has notarization ticket (unusual but not wrong)"
          else
            echo "‚úÖ DMG is unsigned (correct - app inside should be notarized)"
          fi
          
          # Test 2: DMG Gatekeeper assessment  
          echo "üîç Test 2: DMG Gatekeeper assessment"
          SPCTL_OUTPUT=$(spctl -a -vvv "$DMG_FILE" 2>&1 || true)
          echo "Gatekeeper output: $SPCTL_OUTPUT"
          if echo "$SPCTL_OUTPUT" | grep -q "accepted"; then
            echo "‚úÖ DMG passes Gatekeeper assessment"
          else
            echo "‚ö†Ô∏è DMG Gatekeeper assessment unclear - checking app inside"
          fi
          
          # Test 3: App inside DMG should be notarized (CRITICAL TEST)
          echo "üîç Test 3: App inside DMG notarization validation"
          MOUNT_POINT="/tmp/eb-test-mount-$$"
          mkdir -p "$MOUNT_POINT"
          
          if hdiutil attach "$DMG_FILE" -mountpoint "$MOUNT_POINT" -quiet; then
            APP_IN_DMG=$(find "$MOUNT_POINT" -name "*.app" -type d | head -1)
            if [ -n "$APP_IN_DMG" ]; then
              echo "Found app: $APP_IN_DMG"
              
              # CRITICAL: Test app notarization
              echo "üîç Testing app notarization with stapler..."
              if xcrun stapler validate "$APP_IN_DMG"; then
                echo "‚úÖ App has valid notarization ticket!"
              else
                echo "‚ùå CRITICAL: App lacks notarization ticket!"
                hdiutil detach "$MOUNT_POINT" -quiet || true
                exit 1
              fi
              
              # Test app with spctl  
              echo "üîç Testing app with spctl..."
              if spctl -a -vvv "$APP_IN_DMG" 2>&1 | grep -q "accepted"; then
                echo "‚úÖ App passes Gatekeeper assessment!"
              else
                echo "‚ùå CRITICAL: App fails Gatekeeper assessment!"
                hdiutil detach "$MOUNT_POINT" -quiet || true
                exit 1
              fi
            else
              echo "‚ùå No app found in DMG"
              hdiutil detach "$MOUNT_POINT" -quiet || true
              exit 1
            fi
            
            hdiutil detach "$MOUNT_POINT" -quiet || true
          else
            echo "‚ùå Failed to mount DMG"
            exit 1
          fi
          
          echo ""
          echo "üéâ SUCCESS: App notarization worked perfectly!"
          echo "‚úÖ App inside DMG has notarization ticket stapled to it"
          echo "‚úÖ App passes Gatekeeper assessment"  
          echo "‚úÖ DMG can be distributed via GitHub releases"
          echo "‚úÖ Ready for distribution"

      - name: Create GitHub release with preserved notarization
        if: runner.os == 'macOS'
        run: |
          echo "üöÄ Creating GitHub release with preserved file attributes..."
          VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
          
          # Create the release
          gh release create "v${VERSION}" \
            --title "Rune Tools Desktop v${VERSION}" \
            --notes-file changelog.md \
            --verify-tag
          
          echo "üì¶ Uploading release assets with preserved notarization..."
          
          # Upload DMG files (containing notarized app)
          for file in dist-electron/*.dmg; do
            if [ -f "$file" ]; then
              echo "Uploading DMG containing notarized app: $file"
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload other platform files
          for file in dist-electron/*.pkg dist-electron/*.zip dist-electron/*.exe; do
            if [ -f "$file" ]; then
              echo "Uploading: $file"  
              gh release upload "v${VERSION}" "$file"
              echo "‚úÖ Uploaded: $(basename "$file")"
            fi
          done
          
          # Upload manifest and signature
          gh release upload "v${VERSION}" release-manifest.json
          gh release upload "v${VERSION}" release-manifest.json.asc
          
          echo "üéâ All assets uploaded successfully with preserved attributes"
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Post-upload notarization validation (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "üîç CRITICAL: Validating uploaded release preserves notarization..."
          VERSION=$(echo "${{ github.ref_name }}" | sed 's/^v//')
          
          # Wait for upload to propagate
          echo "‚è≥ Waiting 30 seconds for GitHub release propagation..."
          sleep 30
          
          # Download the uploaded DMG
          DOWNLOAD_DIR="/tmp/release-validation-$$"
          mkdir -p "$DOWNLOAD_DIR"
          cd "$DOWNLOAD_DIR"
          
          # Download using curl to simulate user experience
          # Debug: Show what files exist
          echo "üîç Debug: Files in dist-electron:"
          ls -la ../../../dist-electron/ || echo "dist-electron not found"
          
          # Get DMG filename from dist-electron directory
          DMG_NAME=$(find ../../../dist-electron -name "*.dmg" -type f 2>/dev/null | head -1 | xargs basename 2>/dev/null)
          if [ -z "$DMG_NAME" ]; then
            # Fallback: use actual GitHub release filename format
            DMG_NAME="Rune.Tools.beta.-${VERSION}-arm64.dmg"
            echo "‚ö†Ô∏è Using expected DMG filename: $DMG_NAME"
          else
            echo "üìã Found DMG filename: $DMG_NAME"
            # URL encode the filename for GitHub downloads (spaces, parentheses, etc.)
            DMG_NAME=$(echo "$DMG_NAME" | sed 's/ /%20/g' | sed 's/(/%28/g' | sed 's/)/%29/g')
            echo "üìã URL encoded filename: $DMG_NAME"
          fi
          RELEASE_URL="https://github.com/familiarcow/rune-tools-desktop/releases/download/v${VERSION}/${DMG_NAME}"
          
          echo "üì• Downloading from GitHub releases: $RELEASE_URL"
          curl -L -o "downloaded.dmg" "$RELEASE_URL"
          
          if [ ! -f "downloaded.dmg" ]; then
            echo "‚ùå CRITICAL: Failed to download DMG from GitHub releases"
            exit 1
          fi
          
          # Validate the app inside the downloaded DMG has notarization
          echo "üîç Validating app inside downloaded DMG..."
          VALIDATION_MOUNT_POINT="/tmp/validation-mount-$$"
          mkdir -p "$VALIDATION_MOUNT_POINT"
          
          if hdiutil attach "downloaded.dmg" -mountpoint "$VALIDATION_MOUNT_POINT" -quiet; then
            DOWNLOADED_APP=$(find "$VALIDATION_MOUNT_POINT" -name "*.app" -type d | head -1)
            if [ -n "$DOWNLOADED_APP" ]; then
              echo "Found app in downloaded DMG: $DOWNLOADED_APP"
              
              # Test app notarization
              if xcrun stapler validate "$DOWNLOADED_APP"; then
                echo "‚úÖ SUCCESS: App in downloaded DMG has valid notarization ticket"
                
                # Test app with spctl
                if spctl -a -vvv "$DOWNLOADED_APP" 2>&1 | grep -q "accepted"; then
                  echo "‚úÖ SUCCESS: App in downloaded DMG passes Gatekeeper"
                  echo "üéâ NOTARIZATION PRESERVED through GitHub releases!"
                else
                  echo "‚ùå CRITICAL: App in downloaded DMG fails Gatekeeper"
                  hdiutil detach "$VALIDATION_MOUNT_POINT" -quiet || true
                  exit 1
                fi
              else
                echo "‚ùå CRITICAL: App in downloaded DMG LACKS notarization ticket"
                echo "‚ùå NOTARIZATION LOST during GitHub upload/download"
                hdiutil detach "$VALIDATION_MOUNT_POINT" -quiet || true
                exit 1
              fi
            else
              echo "‚ùå CRITICAL: No app found in downloaded DMG"
              hdiutil detach "$VALIDATION_MOUNT_POINT" -quiet || true
              exit 1
            fi
            hdiutil detach "$VALIDATION_MOUNT_POINT" -quiet || true
          else
            echo "‚ùå CRITICAL: Failed to mount downloaded DMG"
            exit 1
          fi
          
          # Cleanup
          rm -rf "$DOWNLOAD_DIR"
          echo "‚úÖ Post-upload validation PASSED - releases preserve notarization"
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

      - name: Windows release upload
        if: runner.os == 'Windows'  
        run: |
          Write-Host "Uploading Windows release assets..."
          $VERSION = "${{ github.ref_name }}" -replace '^v', ''
          
          # Upload Windows files
          Get-ChildItem dist-electron/*.exe, dist-electron/*.zip | ForEach-Object {
            if (Test-Path $_.FullName) {
              Write-Host "Uploading: $($_.Name)"
              gh release upload "v$VERSION" $_.FullName
              Write-Host "Uploaded: $($_.Name)"
            }
          }
          
          # Upload manifest files (created by macOS job)  
          if (Test-Path release-manifest.json) {
            gh release upload "v$VERSION" release-manifest.json
            gh release upload "v$VERSION" release-manifest.json.asc
          }
          
          Write-Host "Windows assets uploaded successfully"
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN }}

